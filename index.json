[
{
	"uri": "/3-codepipeline/3.1-createbucket/",
	"title": "Create a new S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Create a new S3 Bucket Find and select S3. Select Buckets, then select Create bucket. Select AWS Region as the region which you are using. In the Bucket name section, enter a valid name. Select Create bucket. Click the bucket you have created. Select the Permissions tab. In the Block public access section, select Edit. Uncheck all then select Save change. Select Edit bucket policy. Enter the Policy as below: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;Statement1\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;*\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:List*\u0026#34;, \u0026#34;s3:Get*\u0026#34;, \u0026#34;s3:Put*\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::fcj-aws-eb-lab\u0026#34;, \u0026#34;arn:aws:s3:::fcj-aws-eb-lab/*\u0026#34; ] } ] } In the Principal block, we allow all AWS Services to perform all actions stated with List, Get and Put on the S3 bucket and objects inside it. Click Save change. "
},
{
	"uri": "/2-elasticbeanstalk/2.1-createvpc/",
	"title": "Create a VPC",
	"tags": [],
	"description": "",
	"content": "Create a new VPC Before starting ,you need to choose one region deploy AWS services, all resources in this lab is created in region Singapore (ap-southeast-1).\nSearch and select ```VPC``. In Resource to create section, select VPC and more Select Auto-generate and type fcj-aws for Name tag auto-generation. Enter 10.10.0.0/16 for IPv4 CIDR Block. Select 2 AZ, 2 Public Subnet and 2 Private Subnet. In NAT Gateways, select In 1 AZ. Select None for VPC Endpoints. Click Create VPC. Click View VPC to view your VPC after creation. "
},
{
	"uri": "/",
	"title": "Implement pipeline for Elastic Beanstalk application",
	"tags": [],
	"description": "",
	"content": "Implement CI/CD workflow for .NET Core application with Github, AWS CodePipeline and AWS Elastic Beanstalk Tổng quan In this workshop, we will together discuss the fundamentals of AWS CI/CD core services like CodeBuild, CodeDeploy and CodePipeline; another service that can be used for deployment without any prior knowledge of infrastructure or scaling is AWS Elastic Beanstalk. Additionally, we will also practice with the sample API application utilizing those services.\nNội dung Introduction Create Elastic Beanstalk Environment Deploy CodePipeline Clean up resources "
},
{
	"uri": "/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "AWS CodeBuild CodeBuild is an AWS service that helps with the continuous integration flow. CodeBuild compiles, run unit-tests to ensure the source being ready for deployment to other services. With CodeBuild, we don\u0026rsquo;t have to worry about the operation, management and scaling of build servers.\nCodeBuild nowadays supports many languages like C#, Java, Javascript, etc. CodeBuild also has prepared build tools like Maven and Gradle or some popular platforms like Docker and Android.\nAWS CodeDeploy CodeDeploy automates deployment to AWS Services like EC2, Lambda, Fargate or even on-premises environments with 2 primary deployment types: In-place deployment and Blue/green deployment.\nAWS CodePipeline CodePipeline is an continuous delivery service that can be used to model, virtualize and automate application deployment steps. When using with CodeBuild, we will have a fully-automated model of build-test-release workflow.\nAWS Elastic Beanstalk Elastic Beanstalk is a PaaS(Platform as a service) service facilitating the deployment and management of our applications. When the developers initializes a new Environment, Elastic Beanstalk will create other resources like EC2, Elastic Load Balancer, Auto Scaling Group, etc\u0026hellip; to make our applications high availability without developer worrying about the management issues.\nSome benefits of Elastic Beanstalk:\nDeploy and manage applications without worrying about infrastructure, load balancing, scaling, etc. Multiple environments: Elastic Beanstalk supports deployment to many environments, so we could have our applications to live on certain environments like Production, Development, Staging, etc. Support various languages and platforms. Cost optimization. With the above architecture model, we have the workflow as follows:\nWhen developers commit their changes and push them to the remote repository, CodePipeline will fetch those changes and upload to S3 Bucket as Source Artifacts. This step is called Source State. In Build Stage, CodeBuild uses Build Artifacts uploaded to S3 Bucket to compile and run tests. After that, CodeBuild will upload Build Artifacts to S3 Bucket. Finally, in Deploy Stage, Build Artifact is uploaded to Elastic Beanstalk Environment. Beanstalk will automatically update the application. Users can access to the application through AWS Route53 DNS. "
},
{
	"uri": "/3-codepipeline/3.2-connecttogithub/",
	"title": "Connect AWS to Github",
	"tags": [],
	"description": "",
	"content": "Connect AWS to Github Find and select CodePipeline. Select Connection in the Settings then click Create connection. Select Provider as Github then type the Connection name. Click Connect to Github. Select Install a new app and follow the instruction to install the application. After installing, select Connect. "
},
{
	"uri": "/2-elasticbeanstalk/",
	"title": "Create Elastic Beanstalk Environment",
	"tags": [],
	"description": "",
	"content": "Fundamentals of Elastic Beanstalk Application: Application is a logical collection of components like Environments, Versions and Environment Configurations. Version: Each Application has many versions. For example, Application with version A uses Mysql and with Version B it uses PostgreSQL. Environment Tier: When we create new Environment, we can choose 1 of 2 tiers: Web server: For Application that serves on HTTP/HTTPS. Worker: For application that pulls tasks of SQS Queue to process. Environment Configuration: The settings of the Application. In this section, we will create a High Availability Environment with AWS provided sample code.\nContent Create a VPC Enable auto-assign public IPv4 address Create EC2 Keypair Create EC2 Instance Profile Deploy the Environment Test the Environment "
},
{
	"uri": "/2-elasticbeanstalk/2.2-enablepublicip/",
	"title": "Enable auto-assign public IPv4 address",
	"tags": [],
	"description": "",
	"content": "Enable auto-assign public IPv4 address Go to VPC, select Subnets, choose subnet fcj-aws-subnet-public1-*. Click Actions then click Edit subnet settings. Check Enable auto-assign public IPv4 address, then click Save. Repeat those steps with subnet fcj-aws-subnet-public2-*. "
},
{
	"uri": "/3-codepipeline/3.3-createpipeline/",
	"title": "Create a new Pipeline",
	"tags": [],
	"description": "",
	"content": "Create a new Pipeline with CodePipeline Find and select CodePipeline. Select Pipelines \u0026gt; Create pipeline. For Pipeline name, enter fcj-aws-pipeline. Pipeline type select V2. Execution mode select Superseded. For Service role select New service role, enter Role name then check Allow AWS CodePipeline to create a service role so it can be used with this new pipeline. In Advanced settings, select Custom location then select Bucket we have prepared. For Source provider select Github(Version 2). Select Connection we have created then choose the repository to deploy. Select the master branch and select Output artifact format as CodePipeline default. Select Trigger as No filter, then click Next. Select Build provider as AWS CodeBuild, then click Create project. Project name enter fcj-aws-proj. Select New service role then enter Role name. Select Use a buildspec file. Check Cloud watch logs checkbox, enter Group name and Stream name prefix. Click Continue to CodePipeline. Select Build type as Single build. Select Next. Select Deploy provider as AWS Elastic Beanstalk. Select Application name and Environment name created in the previous steps. Review your choices and click Create pipeline. Although we have successfully created a new Pipeline, our Pipeline still can\u0026rsquo;t run. That because the CodePipeline Service Role doesn\u0026rsquo;t have permissions to perform actions on the Elastic Beanstalk environment. So that we have to add policy to the Service Role to make it work.\n"
},
{
	"uri": "/2-elasticbeanstalk/2.3-createkeypair/",
	"title": "Create EC2 Keypair",
	"tags": [],
	"description": "",
	"content": "Create EC2 Keypair In search bar, type EC2, select EC2. Scroll down to Network \u0026amp; Security, select Key Pairs. Select Create key pair. For Name, type aws-keypair, select .pem for Private key file format. Click Create key pair. Successfully create a new keypair. "
},
{
	"uri": "/3-codepipeline/",
	"title": "Deploy CodePipeline",
	"tags": [],
	"description": "",
	"content": "Deploy CodePipeline In this section, we will together add a CI/CD workflow for our .NET 6 application pushed to this repository. This application has only one endpoint as \u0026ldquo;/\u0026rdquo; return the text Hello world.\nTo carry out the content in this section, you should clone this repository and push it to your own repository.\nContent Create a new S3 Bucket Connect AWS to Github Create a new Pipeline Add Policy for Service Role Test the Pipeline "
},
{
	"uri": "/3-codepipeline/3.4-addrolepolicy/",
	"title": "Add Policy for Service Role",
	"tags": [],
	"description": "",
	"content": "Add Policy for Service Role Find and select IAM. Select Roles then select Service Role CodePipeline has created. Select Add permissions \u0026gt; Attach policies. Find and check the AdministratorAccess-AWSElasticBeanstalk policy. Select Add permissions. "
},
{
	"uri": "/4-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Clean up resources Delete Pipeline\nGo to CodePipeline. Select Pipeline we have created. Select Delete pipeline. Delete CodeBuild Project.\nGo to CodeBuild. Select Project we have created. Select Actions \u0026gt; Delete. Delete Github Connection\nSelect Settings \u0026gt; Connections. Select Connection we have created. Select Delete. Delete Elastic Beanstalk Application\nGo to Elastic Beanstalk. Select Applications then select Application we have created. Select Actions \u0026gt; Delete application. Delete S3 Bucket\nGo to S3 Select elasticbeanstalk- bucket. Select Permissions tab, Scroll down to Bucket Policy, select Delete. Empty and Delete elasticbeanstalk- bucket. Empty and Delete Bucket created to store Artifacts. Delete IAM Role\nGo to IAM. Select Roles. Select Role we have created. Delete Keypair\nGo to EC2. Select Key Pairs. Delete Keypair we have created. Delete NAT Gateway\nGo to VPC. Select NAT Gateways. Delete NAT Gateway we have created. Release Elastic IP\nSelect Elastic IPs in VPC. Select IP we used for the lab. Select Actions \u0026gt; Release Elastic IP. Delete VPC\nGo to VPC. Select VPC we have created. Delete VPC. "
},
{
	"uri": "/2-elasticbeanstalk/2.4-instanceprofile/",
	"title": "Create EC2 Instance Profile",
	"tags": [],
	"description": "",
	"content": "Create a new EC2 Instance Profile Find IAM, select IAM. Select Roles then click Create role. Select AWS Service for Trusted entity type. Scroll down and select EC2, then click Next. Find and select AWSElasticBeanstalkWebTier policy. Click Next. Enter fcj-aws-ec2-instance-profile for Role name. Click Create role. "
},
{
	"uri": "/2-elasticbeanstalk/2.5-createenv/",
	"title": "Deploy the Environment",
	"tags": [],
	"description": "",
	"content": "Create a new Application Find Elastic Beanstalk and select Elastic Beanstalk. Select Applications and then click Create application. Enter fcj-aws-application for Application name. Click Create. Create a new Environment Go to the console of our fcj-aws-application application and click Create new application. In Environment tier, Select Web server environment. Type fcj-aws-application-prod-env for both Environment name and Domain. Click Check availability to check if your name is valid. In Platform, select Managed platform for Platform type and then choose .NET Core on Linux. Select Sample application for Application code to utilize AWS providing source code. In Presets section, select High availability for building high availability environment. Click Next. Select Create and use new service role to generate new service role automatically. Select aws-keypair and fcj-aws-ec2-instance-profile created in the previous steps. Click Next. Select fcj-aws-vpc. Select 2 Private Subnet for Instance Subnets. Scroll down then select Next. Select 1 minute for Monitoring interval, that means EC2 instance will send metrics for each minute. When initialization, Elastic Beanstalk creates a new Security Group for EC2 Instance, so we can skip EC2 security groups section. Select Load balanced for Environment type then type the number of minimum instances and maximum instances. Instance types, select t2.micro. In the Load balancer subnets section, select 2 Public Subnet. AWS by default selects 2 Private Subnet, so if we leave it as its default values, the load balancer can\u0026rsquo;t receive traffic.\nSelect Application load balancer and Dedicated for Load balancer type. Select Next. Select Enhanced for Health reporting system. Select Activated for Log streaming so we can view logs using CloudWatch. Enter your email to receive significant messages from Elastic Beanstalk Environment. Deployment policy select Rolling and leave others as their default values. Deployment policy types:\nAll at once: Deploy the new version to all instances simultaneously. All instances in your environment are out of service for a short time while the deployment occurs. Rolling: Deploy the new version in batches. Each batch is taken out of service during the deployment phase, reducing your environment\u0026rsquo;s capacity by the number of instances in a batch. Rolling with additional batch: Deploy the new version in batches, but first launch a new batch of instances to ensure full capacity during the deployment process. Immutable: Deploy the new version to a fresh group of instances by performing an immutable update. Traffic splitting: Deploy the new version to a fresh group of instances and temporarily split incoming client traffic between the existing application version and the new one. Select Activated for Instance log streaming. Select Next. Review your choices and select Submit. Wait for about 10 minutes for the environment to be created. "
},
{
	"uri": "/3-codepipeline/3.5-testpipeline/",
	"title": "Test the Pipeline",
	"tags": [],
	"description": "",
	"content": "Test the Pipeline Go back to the Pipeline interface, check if all Stages has successfully run. Go to Elastic Beanstalk, view Event happening when Elastic Beanstalk operating to upgrade the Application to new version. Click the DNS and view result. Now you could try adding new commit to Github like changing the endpoint /\u0026rsquo;s response(\u0026ldquo;Hello world\u0026rdquo; \u0026gt; \u0026ldquo;Hello world 123\u0026rdquo;) to see how Pipeline work.\n"
},
{
	"uri": "/2-elasticbeanstalk/2.6-testenv/",
	"title": "Test the Environment",
	"tags": [],
	"description": "",
	"content": "Test the Environment When successfully creation, the Environment has its Health status as Ok. We can view our application by clicking on the DNS. Select the Events tab to view resources created or being creating. Select the Health tab to check for instance statuses. Select Logs then select Request logs \u0026gt; Full to fetch EC2 Instance log files. "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]